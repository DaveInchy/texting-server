"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processRequest = void 0;
const graphql_1 = require("graphql");
const utils_1 = require("@graphql-tools/utils");
async function processRequest({ request, params, enveloped, fetchAPI, onResultProcessHooks, }) {
    var _a;
    if (request.method !== 'GET' && request.method !== 'POST') {
        throw (0, utils_1.createGraphQLError)('GraphQL only supports GET and POST requests.', {
            extensions: {
                http: {
                    status: 405,
                    headers: {
                        Allow: 'GET, POST',
                    },
                },
            },
        });
    }
    if (params.query == null) {
        throw (0, utils_1.createGraphQLError)('Must provide query string.', {
            extensions: {
                http: {
                    status: 400,
                    headers: {
                        Allow: 'GET, POST',
                    },
                },
            },
        });
    }
    let document;
    try {
        document = enveloped.parse(params.query);
    }
    catch (e) {
        if (e instanceof graphql_1.GraphQLError) {
            e.extensions.http = {
                status: 400,
            };
        }
        throw e;
    }
    const operation = (_a = (0, graphql_1.getOperationAST)(document, params.operationName)) !== null && _a !== void 0 ? _a : undefined;
    if (!operation) {
        throw (0, utils_1.createGraphQLError)('Could not determine what operation to execute.', {
            extensions: {
                http: {
                    status: 400,
                },
            },
        });
    }
    if (operation.operation === 'mutation' && request.method === 'GET') {
        throw (0, utils_1.createGraphQLError)('Can only perform a mutation operation from a POST request.', {
            extensions: {
                http: {
                    status: 405,
                    headers: {
                        Allow: 'POST',
                    },
                },
            },
        });
    }
    const validationErrors = enveloped.validate(enveloped.schema, document);
    if (validationErrors.length > 0) {
        validationErrors.forEach((error) => {
            error.extensions.http = {
                status: 400,
            };
        });
        throw new utils_1.AggregateError(validationErrors);
    }
    const contextValue = (await enveloped.contextFactory());
    const executionArgs = {
        schema: enveloped.schema,
        document,
        contextValue,
        variableValues: params.variables,
        operationName: params.operationName,
    };
    const executeFn = operation.operation === 'subscription'
        ? enveloped.subscribe
        : enveloped.execute;
    const result = await executeFn(executionArgs);
    let resultProcessor;
    for (const onResultProcessHook of onResultProcessHooks) {
        await onResultProcessHook({
            request,
            result,
            resultProcessor,
            setResultProcessor(newResultProcessor) {
                resultProcessor = newResultProcessor;
            },
        });
    }
    if (!resultProcessor) {
        return new fetchAPI.Response(null, {
            status: 406,
            statusText: 'Not Acceptable',
        });
    }
    return resultProcessor(result, fetchAPI);
}
exports.processRequest = processRequest;
